---
title: "VALIDATION_OF_SERUM_ANALYSIS"
output: html_notebook
---

#Mise en place des paramètres de code
```{r}
#frequences du spectre à étudier
freq_min=800
freq_max=1800

#Valeur des fenêtres de splines
spline_succession=c(9,7,5)

#set.seed
XX= 12
```

## Importation des  packages
```{r}
#library(tidyverse)
library(dplyr)
library(prospectr)
library(fdasrvf)
library(wavethresh)
library(randomForest)
library(fields)

dircode = "~/Dropbox/DPSMET_2021/CODES/"
source(paste(dircode,"PretraitementSpectres.R",sep=""))
```

## Importation des données
```{r}
Snir = read.csv("~/Dropbox/DPSMET_2021/données d'entrée/Entrées DM IR/Cal_frotti_aligned.csv", header=TRUE, sep=",",row.names=2,dec=".")
ident = row.names(Snir)
Snir=Snir[,-1]

freq = as.numeric(substr(colnames(Snir),2,5))

dimS = dim(Snir)
print(paste(dimS[1]," spectres NIR"))

Y = read.csv("~/Dropbox/DPSMET_2021/données d'entrée/Entrées DM IR/phenotype_set1.csv",header=TRUE, sep=",",row.names=1,dec=".")
```
####normalisation
```{r}
finger=fingerprint=c(which(freq>freq_min & freq<freq_max))
new<- Snir[-c(3,97),finger]

w_f=finger
finger = freq[w_f]
```
##B-spline du jeu de calibration
```{r}
#succession de coef spline appliquée à l'ensemble des spectres##################
b=spline_succession
p = length(finger)
VI = matrix(0,length(b),p)
x_all = NULL
cnt = 1
L = 0
x_recom=NULL
for (i in b){
  nBasis = round(p/i)
  L = L + nBasis
  x = projRecomp(as.matrix(new), nBasis = nBasis)
  print(nBasis)
  print(dim(x$coeffProj))
  if (cnt==1){
    x_all = x$coeffProj
    x_recom= x$foncRecon
    print(dim(x_recom))
  } else {
    x_all = cbind(x_all,x$coeffProj)
    x_recom= cbind(x_recom, x$foncRecon)
    print(dim(x_all))
    print(dim(x_recom))
  }
  cnt = cnt+1
}
```
Machine learning model
```{r}
library(caret)
library(pROC)

set.seed(123)
dataset = data.frame(x_all)[-96,]

y=as.numeric(as.character(Y$ASAT))[-96]
wna=which(is.na(y))

dataset=dataset[-wna,]
y=y[-wna]
dataset$Class=y

pred_all  = y_test  = NULL

for (rep in (1:20)){
  inTraining <- createDataPartition(dataset$Class, p=.80, list = FALSE)
  training <- dataset[ inTraining,]
  testing  <- dataset[-inTraining,]
  rf=randomForest(Class~.,data = training, mtry=200, ntree=2000)
  pred = predict(rf, newdata = testing)
  pred_all = c(pred_all,pred)
  y_test =c(y_test, testing$Class)
}

plot(y_test, pred_all)
```
Important variables
```{r}
## plot des variables importantes################################################
VI_rf_default = matrix(0,length(spline_succession),p)
i_deb = 0
cnt = 1
for (i in spline_succession){
  nBasis = round(p/i)
  end = min(nBasis*i,p)
  #VI[cnt,1:end] = c(t(matrix(rf$importance[,4]/sum(arbre$importance)*100,nBasis,i)))[1:end]
  VI_rf_default[cnt,1:end] = c(t(matrix(rf$importance[i_deb+(1:nBasis)],nBasis,i)))[1:end]
  i_deb = i_deb+nBasis
  cnt = cnt+1
}
matrix_plot=t(VI_rf_default)
rownames(matrix_plot)=finger
colnames(matrix_plot)=spline_succession

image.plot(matrix_plot,col = hcl.colors(10, "Spectral", rev = TRUE), axes=F ,lab.breaks=NULL)
image(matrix_plot,col = hcl.colors(10, "Spectral", rev = TRUE),  axes=FALSE, add=TRUE)
axis(2, at=seq(0,1, length=length(spline_succession)), labels=colnames(matrix_plot), lwd=0, pos=0)
axis(3, at=seq(0,1, length=485), labels=rownames(matrix_plot), lwd=0, pos=-0.65)

```